
#1 
Helping video for simplification: https://www.youtube.com/watch?v=0as464WmfCo  

Not/And/Or Statement: X:= A or ( B and C )     Y:= not A or (A and C)

Helping site: https://stackoverflow.com/questions/33270028/transform-an-expression-only-using-nand-logic-gates#:~:text=I%20would%20suggest%20using%20the,replaced%20also%20by%20NAND%20gates). 

Nand Statement: X:= nand(nand (A,A), nand(B,C))  Y:= nand(A, nand(C,C))


#2 refer to prob_2.pdf

#3 fizzbuzz.c added in github folder

#4
JMP 		start
StartNum: 0 
counter: 1 
Limit:  256
	LOAD		[StartNum]
	WRITE	0x0
	ADD		[Counter]
	ADD		1
	STORE	[Counter]
LOAD		[Counter]
	SUB		
	STORE	[Counter]

#5
        JMP     start
zero: 0x00000000
one: 0x00000001
max: 0x00000100 //256 in decimal
count: 0x00000000
Start:	LOAD  	zero    //Initialize counter to 0
	    STORE	count
loop:	LOAD	count   //get current counter value
	    WRITE	0x8     // output to port 0x8
	    ADD		one     //increment counter
	    STORE	count   //store updated counter
	    SUB		max     //Compare with 256
	    JLZ		loop    // if Count < 256, continue loop
End:    JMP		end    




#7
        JMP     start
a: 0x00000000
b: 0x00000000
temp: 0x00000000
zero: 0x00000000
START: READ 0x100
        STORE a
        READ 0x100
        STORE b
gcd_loop
        LOAD b // If b = 0, done
        JZ output_gcd

        LOAD a //If a >= b, then a = a - b
        SUB b
        JLZ else_part // If a < b, jump to else

        SUB b // a >= b case: a =- a-b
        STORE a 
        JMP gcd_loop
else_part // a < b case: swap a and b
        LOAD a
        STORE temp
        LOAD b
        STORE a 
        LOAD temp
        STORE b
        JMP gcd_loop
output_gcd
        LOAD a
        WRITE 0x200
end:    JMP end

#8 
STORE 0x1000 	; Stores the current value of the accumulator here, a temporary holder
LOAD	0x30AA 	; Loads value from memory address 0x30AA into the accumulator
STORE 0x30AA	; Stores the new value of the accumulator back into memory
LOAD 0x1000	; Loads original accumulator value from the temporary holder

#9
JLZ start		; If accumulator is less than 0, jump to repeat process
JMP 0x837BBE1	; If machine reaches this, then it means it found a value greater than 0. So the program can jump to the address. 
JMP start		; If accumulator hasnâ€™t a value less than 0, it repeats the process here by going back to start. 

#10 Part 1
    It is the XOR swap algorithm,where these three XOR operations swap the values in registers r8 and r9. After executing these three instructions, the values in r8 and r9 have been swapped without needing to use temporary register. The data that was originally in r8 is now in r9 and vice versa. 

#10 Part 2
    The XOR swap works being XOR is reversible, meaning when XORing twice with the same value, it would return the original. Therefore the sequences used in the first XOR combines both values, the XORs again to extract the originals in swapped order. 