
#5
        JMP     start
zero: 0x00000000
one: 0x00000001
max: 0x00000100 //256 in decimal
count: 0x00000000
Start:	LOAD  	zero    //Initialize counter to 0
	    STORE	count
loop:	LOAD	count   //get current counter value
	    WRITE	0x8     // output to port 0x8
	    ADD		one     //increment counter
	    STORE	count   //store updated counter
	    SUB		max     //Compare with 256
	    JLZ		loop    // if Count < 256, continue loop
End:    JMP		end    


#7
        JMP     start
a: 0x00000000
b: 0x00000000
temp: 0x00000000
zero: 0x00000000
START: READ 0x100
        STORE a
        READ 0x100
        STORE b
gcd_loop
        LOAD b // If b = 0, done
        JZ output_gcd

        LOAD a //If a >= b, then a = a - b
        SUB b
        JLZ else_part // If a < b, jump to else

        SUB b // a >= b case: a =- a-b
        STORE a 
        JMP gcd_loop
else_part // a < b case: swap a and b
        LOAD a
        STORE temp
        LOAD b
        STORE a 
        LOAD temp
        STORE b
        JMP gcd_loop
output_gcd
        LOAD a
        WRITE 0x200
end:    JMP end

#10 Part 1
    It is the XOR swap algorithm,where these three XOR operations swap the values in registers r8 and r9. After executing these three instructions, the values in r8 and r9 have been swapped without needing to use temporary register. The data that was originally in r8 is now in r9 and vice versa. 

#10 Part 2
    The XOR swap works being XOR is reversible, meaning when XORing twice with the same value, it would return the original. Therefore the sequences used in the first XOR combines both values, the XORs again to extract the originals in swapped order. 